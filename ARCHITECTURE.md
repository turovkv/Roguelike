## Общие сведения о системе

### Назначение
* Реализация игры с консольной графикой в стиле roguelike

### Границы системы
* однопользовательская игра
* без подключения к интернету
* запуск и сама игра происходит в консоли
* 2д графика, не созраняется состояние

### Контекст системы
* Происходит внутри консоли, взаимодействует с клавиатурой пользователя


## Ключевые требования

### Технические требования

* Игра должен быть кроссплатформенной
* Язык программирования должен поддерживать объектно-ориентированную парадигму
* Должен существовать open-source фреймворк для работы с консольной графикой для нашего языка программирования

### Бизнес-ограничения

* Игра является полностью бесплатной
* Разработка происходит спринтами: чаще всего размером в неделю, но иногда может двигаться, в зависимости от лояльности наших заказчиков

### Качественные характеристики системы

* Для хорошей сопровождаемости разработчики будут поддерживать актуальный дизайн-док, писать тесты ко всем модулям и комментарии ко всем публичным классам и методам
* Для хорошей расширяемости мы будем стараться использовать интерфейсы и базовые классы для того, чтобы можно было добавить новые реализации
* Так как у нас не веб-сервис и пользователь всегда один, то о масштабируемости речи не идёт
* Сопровождаемость и удобство разработки важнее производительности, поэтому мы откажемся от С++ и игра не будет летать, но скорость будет на приемлемом уровне
* Игра будет распространяться с помощью репозитория на гитхаб, никак вирусов или ещё чего-то угрожающего вашей безопасности там не планируется

### Ключевые функциональные требования
* поддерживаем смену локаций(заходим в комнату)
* двумерная карта, состоит из клеток
* есть генерация карты
* есть стены, противники, предметы
* на стены нельзя заходить
* 1 игрок, ходит по клеткам
* есть инвентарь: предметы
* есть возможность убивать монстров.
  * персонажи, пытающиеся занять одну клетку, наносят друг другу урон в соответствии с их параметрами
  * урон уменьшает количество хитпойнтов, и если их становится 0 или меньше, персонажумирает
* монстры могут наносить нам урон, их 3 вида:
  * агрессивные (атакуют игрока, как только его видят)
  * пассивные (просто стоят на месте)
  * трусливые (стараются держаться на расстоянии от игрока)
* система уровней
  * при убийстве моба персонажу игрока начисляется некоторое количество очков опыта;
  * при наборе достаточного количества опыта персонаж получает следующий уровень, что приводит к росту его характеристик.
* если игровой персонаж умер, то игра начинается заново
* Пошаговая: ничего не меняется, если нет ввода от пользователя.

## Слои в архитектуре:
* ввод пользователя
* Logic
* GUI
  * Инвентарь
  * Карта
  * Инструкции
  * Персонаж
* Model
  * Инвентарь
  * Карта
  * Инструкции
  * Персонаж


## Ключевые требования (architectural drivers)
- мультиплатформенность
- возможность добавления разных языков

## Роли и случаи использования

- Типичный пользователь: Вова, представитель более старшего поколения (30-45 лет), любящий олдскульную консольную графику и нелюбящий казуальщину. Скорее всего, гик, так как игра однопользовательская и значит непопулярна в нынешних реалиях.

- Сценарий использования: Вова приходит после работы, поговорил с женой и детьми и решил пройти уровень в нашей прекрасной игре (один или всей семьей). После игры, если умер, то начал заново с рандомной карты, если нет, то пошел спать.

## Композиция

- Архитектуру выбрали слоистую, потому что наша архитектура хорошо делится на слои, но при этом она более расширяема, чем обычный MVC.
  Диаграмма компонент: https://drive.google.com/file/d/1ddz7-SiaGhij1iucSZbKCaXODO9mGBGw/view?usp=sharing

- Диаграмма состоит из 4х слоев, первый слой отвечает за считывание данных, второй отвечает за  логику и функциональность сущностей, третий слой отвечает за отображение сущностей и последний слой отвечает за хранение информации о сущностях.

## Логическая структура


### Input
https://drive.google.com/file/d/1wt8P4O_gBL7xdB4iXXCHCbRvJtD7d0rX/view?usp=sharing

- Считываем ввод пользователя
- С помощью CommandFactory создаем команду, соответствующую кнопке, нажатой пользователем 
- У этой команды вызываем метод `execute()`, который будет выполнять сценарий рассматриваемой кнопки 

### Logic
https://drive.google.com/file/d/1bV6EcTbEd8aW0aVcDHciq7vDdPQQ3i6G/view?usp=sharing

Класс `LogicFaсade` хранит состояние и определяет к какой сущности обращается пользователь, имеет методы для обработки действий. Все классы логики для каждой сущности наследуются от интерфейса `Logic`, который содержит методы для обработки действий пользователя и отрисовки сущности.
- **Интерфейс `Logic`** имеет методы общие для всех видов логики. Интерфейс хранит в себе поле `GUI`, которое отвечает за отрисовку данного объекта. Метод `draw()` нужен чтобы удобнее робращаться к `GUI` и отрисовывать текущий объект. Остальные методы служат для обработки действия, которое выполняется при нажатий конкретной кнопки, которая используется в нашем приложении.
- **Класс `LogicFaсade`** хранит состояние и определяет к какой сущности обращается пользователь, имеет методы для обработки действий. Класс `LogicFacade` хранит в себе текущую логику `current`, то есть понимает с каким объектом сейчас взаимодействует пользователь. И хранит в себе поля `map`, `inventory` и `instruction`, которые содержат логику для карты, инвенторя и для иструкции. Класс `LogicFacade` имеет методы для обратки всех клавиш, которые используются в игре.
- **Класс`MapLogic`** наследует интрефейс `Logic` и отвечает за логику для карты и хранит в себе `MapModel` и `Character`.
  - обновляет расположение всех мобов
  - знает видна ли одна клетна из другой
- **Класс`InventoryLogic`** наследует интерфейс `Logic` и отвечает за логику для инвентаря и хранит в себе `InventoryModel` и `Character`.
- **Класс`InstructionLogic`** наследует интрефейс `Logic` и отвечает за логику для инструкций и хранит в себе `InstructionModel`.
- **Класс `CharacterStrategy`** с единственным методом `move(Coordinates) -> Coordinates` описывает текущее **состояние** врага. Изменения состояний пользователь описывает в методе `Enemy::wantedMove()` На данный момент выделяем следующие виды:
  - PassiveStrategy
  - AgressiveStrategy
  - SneakyStrategy
- **Класс `ConfusedCharacterDecorator`** декорирует в себе логу оглушенного врага

### Model
https://drive.google.com/file/d/1WvhdbsDgOOYU3rsElY9ul49OPPVi-kF6/view?usp=sharing

- Для каждой сущности свой класс, который хранит поля с информацией об этой сущности, а также имеет геттеры и сеттеры.
  Для карты хранится список всех клеток, и методы которые позволяют менять клетки и загружать карту.
  Для инструкций хранятся константные поля в которых хранятся название инструкции и ее описание и авторы.
  Для  инвентаря хранится список его элементов и методы которые позволяют его изменять.

- Item. Это интерфейс, от которого мы будем наследовать наши предметы, внутри будет хранится их состояние и функциональность. У Item есть абстрактный метод use, который принимает состояние персонажа, этот метод как раз таки и отвечает за функциональность:
  - яблоко – повышение здоровья
  - доспехи – увеличение брони

- Также мы от Item наследовали два интерфейса: Disposable и NonDisposable – элементы, которые исчезают из инвентаря при использовании, и элементы, которые нет, соответственно

- Есть абстрактный класс Character, который символизирует собой любую живую сущность: количество здоровья, наносимого урона, мощность брони. Также есть метод атаковать другого персонажа.
  От Character мы наследуем два класса живых существ, которые мы сейчас используем в нашей игре: PlayerCharacter и NPC

- Класс `Enemy` хранит в себе информацию о враге, его координаты, стратегию и максимальное количество здоровья 
  Класс `ClonableEnemy` наследуется от класса `Enemy` и имеет метод `clone` для создания клона врага

- Класс `CloneableEnemy` содержит логику, клонирования мобов. Могу клонироваться только скелеты. Клонирование происходит при ударе с 10% вероятностью

- Для создания мобов в различных стилях используется фабрика `EnemyFactory` которая содержит методы генерирующие `Enemy` в зависимости от переданного стиля, который хранится в классе `EnemyStyle`.

- Есть класс `Cell`, это абстрактный класс, от которого мы будем наследовать все типы нашех клеток. Мы поддерживаем функциональность хранения предмета клеткой, а также там может находится монстр, для этого мы в абстрактном классе храним ссылки на `Item` и `NPC` соответственно. Сейчас мы игровую клетку разделяем на три типа: `EmptyCell` - клетка, по которой можем ходить, `WallCell` - клетка стена, а также `PortalCell` - клетка портал, для перемещения в подземелье

- Для герерации карты используется класс `FieldBuilder`, который генерирует карту в завсимости от `EnemyFactory` и параметров ширины, высоты и файла с картой. Внутри себя `FieldBuilder` использует интерфейс `FieldGenerator` от которого наследуются следующие классы
- `BSPFieldGenerator` генерирует карту с помощью BSP дерева
- `FileFieldGenerator` генерирует карту из файла
- `JsonFileFieldGenerator` генерирует карту из json 
- `TextFileFieldGenerator` генерирует карту из текстового файла

#### Система уровней
* В конфигурационном файле задаётся сколько нужно экспы до следующего уровня и сколько здоровья и урона мы получаем за новый уровень
* Экспу мы получаем при убийстве моба
* Экспа моба равна сумме его здоровья и урона


### GUI
https://drive.google.com/file/d/1fgEZ-A2HVXgz220mMKunQudRTtRFs2kn/view?usp=sharing

* Drowable - интерфейс с методом draw, который рисует обьект, от него наследуются все следующие классы
* MapGUI - хранит characterGUI и MapModel, отрисовывает карту и состояние героя
* InventoryGUI - хранит characterGUI и InventoryModel, отрисовывает инвентарь и состояние героя
* InstructionsGUI - хранит InstructionsModel, отрисовывает инструкции
* CharacterGUI - хранит Character, отрисовывает hp, maxhp, damage, attack

## Взаимодействия и состояния (диаграммы последовательностей и конечных автоматов и их текстовое описание — даже если для вашей архитектуры они не очень полезны, нарисуйте,потренироваться).
https://drive.google.com/file/d/1at57KtKZsUX42IS_3tCQXKzUlNzkBmTd/view?usp=sharing

* Пользователь по нажатию кнопки может переключать окна Карта, Инвентарь, Подсказка.
* Герой может попробовать пойти на клетку. Если это стена, то он не переходит на нее. Если это монстр, то он бьет его. Иначе переходит наклетку и если там лежит предмет, то может его взять. Если умер в бою, то переродился и начал заново.

## Диаграмма последовательностей
https://drive.google.com/file/d/1LgGHbkFbbYgAHDdaigGdu-3iRg5wwwtc/view

- У `MapLogic` вызывается метод `processSomeArrow`. Далее у `Character` вызывается метод `attack`, куда мы передаём `NPC`. Далее мы отрисовываем текущее состояние игры.

## Алгоритм генерации поля с помощью BSP

* Делим пространство на части, пока можем, что конфигурируется минимальным размером клетки, попутно строя дерево
* В листах создаём комнаты
* Для каждой ноды соединяем комнаты каких-нибудь двух комнат правого и левого поддерева
* Обходим все комнаты и туннели, помечая пройденные клетки `WALKABLE`

## Управление

- Навигация персонажа по карте осуществляется через клавиатуру, а именно через клавиши стрелочек:
  - Клавиша влево – движение влево
  - Клавиша вправо – движение вправо
  - Клавиша вверх – движение вперед
  - Клавиша вниз – движение вниз

- Взаимодействие с миром. На данном этапе мы выделяем только две формы взаимодействия с внешним миром:
  - Взаимодействие с предметами: можно брать и оставлять предмет на игровой клетки
  - Взаимодействие с монстрами: их можно бить и всячески над ними издеваться

# Аналоги

* Нашу консольную игру мы решили реализовывать на языке Kotlin. Для работой с консолью мы используем библиотеку lanterna. Мы также рассматривали аналоги данной библиотеки, такие как: javacurses. Их самой главной проблемой оказалась старость это выражалось в том, что эти библиотеки уже давно никто не поддерживает. Также еще одно преимущество lanterna это документация и много уроков в интернете.

* Также выбор языка стал очень большой проблемой для нас. Мы думали над четырьмя языками, которые узнали при обучении в нашем замечательном университете: C++, Haskell, Java, Kotlin.
  *   Мы сразу отказались от Java, так как это очень консервативный язык.
  *   Хотят у нас и был опыт с ncurses, но мы не взяли плюсы, потому что имеем опыт с прострелом ног
  *   Также мы очень долго рассматривали Haskell, но решили отказаться от него, потому что мыло людей на этой планете понимают всю его красоту
  *   Поэтому мы выбрали языка Kotlin

* Архитектуру выбрали слоистую, потому что наша архитектура хорошо делится на слои, но при этом она более расширяема, чем обычный MVC.
